# Чек лист чистого кода
Контрольный список разработчика, в основном основанный на книге **"Чистый код" Роберта К. Мартина**

## Содержание :bookmark_tabs:
  - [Именование всего](#Именование-всего-u5272)
  - [Функции](#Функции-microscope)
  - [Форматирование](#Форматирование-rainbow)
  - [Объекты и структуры данных](#Объекты-и-data-структуры-данных-two_men_holding_hands)
  - [Обработка ошибок](#Обработка-ошибок-interrobang)
  - [Юнит-тесты](#Юнит-тесты-umbrella)
  - [Классы](#Классы-school_satchel)
  - [Появление](#Появление-green_book)
  - [Параллелизм](#Параллелизм-arrows_clockwise)
  - [Пахнущий код](#Пахнущий-код-speak_no_evil)
  - [Почетные упоминания](#Почетные-упоминания-basecamp)

<br/>

## Именование всего :u5272:

- [x] **Имя должно раскрывать намерение**
  - Оно должно сообщать, почему объект существует, что он делает и как используется.
  - Имя должно описывать контекст.

- [x] **Избегайте использования аббревиатур**
  - Используйте `hypotenuse` вместо `hp`.

- [x] **Не описывайте имя с помощью структуры данных**
  - Используйте `accounts` вместо `accountList`.

- [x] **Не используйте вместе имена, которые различаются совсем незначительно**
  - Трудно найти разницу между `ControllerForEfficientHandlingOfStrings` и `ControllerForEfficientStorageOfStrings` :dancers:

- [x] **Не давайте переменным имена только для удовлетворения компилятора**
  - Не называйте что-то `name1`, потому что `name` уже занято.

- [x] **Избегайте использования шумовых слов**
  - `ProductData` и `ProductInfo` означают примерно одно и то же.
  - Подобно этому, слова, такие как `a`, `an`, `the`, также являются шумовыми словами, например, назвать переменную `product` достаточно, не нужно `theProduct`.
  - Шумовые слова также **избыточны**, используйте `name` вместо `nameString`.

- [x] **Различайте имена таким образом, чтобы читатель знал, к чему обращаться.**

- [x] **Используйте произносимые имена**

- [x] **Используйте легко находимые имена**
  - Используйте константы вместо жестко закодированных значений, `WORK_DAYS_PER_WEEK = 5` вместо просто 5.

- [x] **Добавляйте единицы измерения к имени переменной**
  - Использование `expiryTimeInSeconds` лучше, чем `expiryTime`.

- [x] **Длина имени должна соответствовать размеру его области видимости**
  - Переменная `i` может быть внутри цикла `for`, но `i` никогда не должна быть переменной экземпляра.

- [x] **Классы и объекты должны быть названы существительными или именными фразами.**
  - Избегайте слов, таких как `Manager`, `Processor`, `Data` или `Info` в названии класса.
  - Если имя вашего класса заканчивается на `er`, `or` или `utils`, стоит пересмотреть ответственность класса.
  - Имя класса не должно быть глаголом.

- [x] **Названия методов должны быть глаголами или глагольными фразами**

- [x] **Когда конструкторы перегружены, старайтесь использовать статические фабричные методы с именами, которые описывают аргументы**
  - `Complex fulcrumPoint = Complex.FromRealNumber(23.0)` лучше, чем `Complex fulcrumPoint = new Complex(23.0)`

- [x] **Выберите одно слово для одной абстрактной концепции и придерживайтесь его**
    - Например, запутанно иметь `fetch`, `retrieve` и `get` как эквивалентные методы разных классов.

- [x] **Не добавляйте излишний контекст**
  - Для приложения "Gas Station Deluxe" плохая идея префиксировать каждый класс `GSD`.
  - Например, используйте `AccountAddress` вместо `GSDAccountAddress`.

- [x] **Допустимо использовать термины компьютерных наук, названия алгоритмов, шаблонов, математические термины**
  - Постоянное использование проблемной области для выбора имен может привести к усложнению, поэтому при необходимости можно использовать имена из области решений.

- [x] **Добавляйте к имени не больше контекста, чем необходимо**
  - Более короткие имена обычно лучше длинных, если они ясны.

<br/>

---

<br/>

## Функции :microscope:

- [x] **Функция должна быть маленькой**
  - Она должна быть меньше чем кажется на первый взгляд :stuck_out_tongue:

- [x] **Блоки внутри `if`, `else`, `while` должны состоять из одной строки, и это, вероятно, должно быть вызовом функции**
  - Это сохраняет обрамляющую функцию маленькой.
  - Это также добавляет документальную ценность, так как вызванная внутри блока функция может иметь хорошо описательное имя.

- [x] **Уровень отступов функции не должен превышать одного или двух**

- [x] **Функции должны заниматься одной задачей, делать это хорошо и делать только ее**
  - Если функция выполняет только те шаги, которые находятся на один уровень ниже указанного имени функции, то функция делает одну задачу.

- [x] **Функции не должны иметь секции внутри себя**
  - Если вы можете разделить функцию на секции, то эта функция, вероятно, выполняет несколько дел.

- [x] **Функция должна иметь один уровень абстракции**
  - Мы должны убедиться, что утверждения внутри нашей функции находятся на одном уровне абстракции.

- [x] **Правило понижения**
  - Абстракция класса должна уменьшаться по мере чтения вниз.

- [x] **Оператор Switch должен быть закопан в низкоуровневый класс, должен появляться только один раз для создания полиморфных объектов и никогда не повторяться**
  - Например, он может быть в `Abstract Factory`, но не должен быть виден нигде больше.

- [x] **Старайтесь иметь функции с 3 аргументами максимум**
  - Старайтесь удерживать количество аргументов на уровне 3-4.
  - Идеальное количество аргументов для функции - ноль. Три аргумента следует избегать, где это возможно. Более трех требует очень особого обоснования.
  - Практически, количество аргументов никогда не должно превышать 4.

- [x] **Если функция собирается преобразовать свой входной аргумент, преобразование должно появляться в качестве возвращаемого значения**
  - Если функция выполняет операцию преобразования своего входа, то выходом этой функции должно быть преобразованное значение.
  - Если функция выполняет преобразование входных данных, она должна делать только это.

- [x] **Следует избегать флагов в аргументах**
  - Функция делает одно дело, если флаг равен `true`, и другое, если флаг равен `false`, тем самым нарушая принцип единственной ответственности.
  - Мы должны разделить функцию на 2 разные функции и вызывать их отдельно.

- [x] **Когда функция требует более 2 или 3 аргументов, если возможно, объедините некоторые из этих аргументов в отдельный класс**

- [x] **Функции не должны иметь побочных эффектов**
  - Мутации входных параметров следует избегать.

- [x] **Функция должна делать одно дело, которое предполагает её имя, и не делать ничего другого**

- [x] **Функции должны либо что-то делать, либо на что-то отвечать (разделение команд и запросов)**
  - Функция должна либо изменять состояние чего-либо, либо возвращать что-либо.

- [x] **Предпочитайте исключения возвращению кодов ошибок**
  - Когда вы возвращаете код ошибки, создается проблема, что вызывающий код должен немедленно обрабатывать ошибку.
  - Также использование `enum`'ов для ошибок создает магнит зависимостей, множество классов должны импортировать и использовать их.

- [x] **Выносите блоки Try/Catch в отдельную функцию**
  - Обработка ошибок - является отдельной задачей. Таким образом, функция, которая обрабатывает ошибки, не должна делать ничего другого.
  - Если в функции есть ключевое слово try, оно должно быть первым словом в функции, и после блоков catch/finally не должно быть ничего.

- [x] **Избегайте дублирования кода**
  - Принцип DRY (Don't Repeat Yourself).

<br/>

---

<br/>

## Форматирование :rainbow:

- [x] **Вертикальный размер файла обычно должен быть в пределах 200 строк**

- [x] **Мы хотим, чтобы исходный файл был похож на газетную статью**
  - Имя должно быть простым, но объяснительным.
  - Верхние части исходного файла должны предоставлять концепции и алгоритмы высокого уровня, т.е. `публичные методы`.
    - Мы должны быть в состоянии понять, что делает класс, взглянув на верхнюю часть класса.
    - Мы должны увидеть, как он это делает, когда прокручиваем вниз.
  - Детали должны увеличиваться по мере перемещения вниз, мы должны видеть больше деталей реализации, т.е. `приватные методы`.
  - Общие правила для расположения методов:
    - public
    - protected 
    - private

- [x] **Вертикальная открытость между концепциями**
  - Каждая строка представляет собой выражение или предложение, и каждая группа строк представляет собой законченную мысль. Эти мысли должны быть отделены друг от друга пустыми строками.
  - Т.е. методы должны быть вертикально разделены пробелами.

- [x] **Переменные должны объявляться как можно ближе к месту их использования**

- [x] **Переменные экземпляра должны объявляться в начале класса**

- [x] **Если одна функция вызывает другую, они должны находиться вертикально близко друг к другу**
  - Вызывающий код должен быть выше вызываемого.
  - `Приватный` метод, который вызывается из `публичного` метода, должен располагаться близко к `публичному` методу.

- [x] **Коды, имеющие сильное концептуальное сходство, должны иметь меньше вертикального разделения между ними**
  Например:
  ```java
    public static void assertTrue(boolean condition) {
       assertThat(condition).isTrue();
    }

    public static void assertFalse(boolean condition) {
       assertThat(condition).isFalse();
    }
  ```

- [x] **Строки кода не должны превышать 120 символов**

- [x] **Используйте пробелы между `операторами`, `параметрами` и `запятыми`**

- [x] **Используйте единый стиль форматирования в команде**
  - Используйте один и тот же файл код-стайла по всей команде.

- [x] **Отступы**
  - Сжатие в одну строку с короткими `if`, `for`, `function()` - не лучшая идея.
  - Даже для однострочных `if`, однострочных `while` - делайте переносы строк и добавляйте отступы.

<br/>

---

<br/>


## Объекты и структуры данных :two_men_holding_hands:

- [x] **Скрывайте реализацию классов с помощью абстракции**
  - Не раскрывайте переменные через геттеры и сеттеры. Вместо этого используйте абстрактные интерфейсы, которые позволяют пользователям манипулировать данными, не зная их реализации.
  - Мы не хотим раскрывать детали наших данных. Вместо этого мы хотим выражать наши данные в абстрактных терминах.

- [x] **Антисимметрия данных/объектов**
  - Объекты должны скрывать свои данные за абстракциями и предоставлять функции, которые работают с этими данными.
  - Структуры данных должны раскрывать свои данные и не иметь значимых функций.

- [x] **Выбор между функциональным кодом и объектно-ориентированным кодом**
  - Функциональный код (код, использующий структуры данных) упрощает добавление новых функций без изменения существующих структур данных (с использованием сопоставления с образцом).
  - Объектно-ориентированный код, с другой стороны, упрощает добавление новых классов (с использованием полиморфизма) без изменения существующих функций.
  - В любой сложной системе будут случаи, когда нам нужно будет добавлять новые типы данных, а не новые функции. В этих случаях наиболее подходящими являются объекты и ООП.
  - С другой стороны, будут также случаи, когда мы захотим добавить новые функции вместо типов данных. В этом случае процедурный код и структуры данных будут более подходящими.
  - Всё является объектом - это миф. Иногда следует использовать простые структуры данных с процедурами, работающими с ними.

- [x] **Закон Деметры**
  - Метод f класса C должен вызывать методы только у:
    - [x] объекта класса C
    - [x] Объекта, созданного f
    - [x] Объекта, переданного в качестве аргумента f
    - [x] Объекта, находящегося в переменной экземпляра C
  - Метод не должен вызывать методы на объектах, которые возвращаются любыми из разрешенных функций.

- [x] **"Train Wrecks"**
  - ```java
    final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
    ```
    Этот вид цепочечных операций называется "Train Wrecks", ввиду схожести с вагонами поездов, и мы должны избегать таких струкутр.
  - Это также нарушение закона Деметры, так как мы вызываем методы на объектах, которые возвращаются.
  - И это разрешено только если используются структуры данных вместо объектов, так как объекты не должны раскрывать свои данные.
  - Но цепочные преобразования допустимы:
  ```java
  someList.map(..).map(..).filter(..)
  ```

- [x] **Гибриды, классы, которые имеют функции, выполняющие значимые действия, и также имеют либо публичные переменные, либо публичные аксессоры и мутаторы**
  - Это может привести к запаху завистливой функции, так как мы раскрываем доступ к переменным, а вызывающий код может быть склонен использовать их.

- [x] **DTO не должны иметь никакого поведения, т.е. они должны быть структурами данных, а не объектами**
  - DTO/значимые объекты должны иметь метод `equals`.
  - Любая операция в значимом объекте должна возвращать новый экземпляр этого класса.
  
<br/>

---

<br/>

## Обработка ошибок :interrobang:

- [x] **Обработка ошибок важна, но если она затрудняет логику, это неправильно**
  - Если в вашей кодовой базе слишком много обработчиков ошибок, разбросанных по разным модулям, код становится нечитаемым по умолчанию.

- [x] **Используйте непроверяемые исключения**
  - Проверяемые исключения нарушают `Принцип открытости/закрытости`. Если вы выбрасываете проверяемое исключение из метода в вашем коде, и обработка находится на три уровня выше, вы должны объявить это исключение в сигнатуре каждого метода между вашим и обработкой. Это означает, что изменение на низком уровне кода может потребовать изменения сигнатур на многих более высоких уровнях.
  - `Инкапсуляция` также нарушается, потому что все функции в пути выброса должны знать о деталях этого низкоуровневого исключения.

- [x] **Предоставляйте контекст с исключениями**
  - Создавайте информативные сообщения об ошибках и передавайте их вместе с вашими исключениями.
  - Укажите операцию, которая не удалась, и тип сбоя.
  - Передавайте стек-трейс.

- [x] **Определяйте классы исключений с точки зрения потребностей вызывающего**
  - Определите исключение таким образом, чтобы вызывающий мог принять решение, основываясь только на исключении.
  - Используйте разные классы только в том случае, если есть ситуации, когда вы хотите поймать одно исключение и позволить другому пройти.

- [x] **Если часть кода выбрасывает много типов исключений, оберните эту часть и выбросьте общее исключение**
  - Используя информацию, переданную с исключением, мы должны быть в состоянии различать ошибки.

- [x] **Оборачивайте вызовы сторонних API**
  - Когда вы оборачиваете сторонний API, вы минимизируете свои зависимости от него.
  - В будущем вы сможете перейти на другую библиотеку без особых штрафов.
  - Оборачивание также упрощает мокирование сторонних вызовов при тестировании вашего кода.

- [x] **Вместо специального потока для исключений используйте паттерн Special Case**
  - Из этого:
    ```java
    try {
      MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
      m_total += expenses.getTotal();
    } catch (MealExpensesNotFound e) {
      m_total += getMealPerDiem();
    }
    ```
    в это:
    ```java
    MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
    m_total += expenses.getTotal();
    ```
    ```java
    public class PerDiemMealExpenses implements MealExpenses {
      public int getTotal() {
        // return the per diem default
      }
    }
    ```
  - Вы создаете класс, который обрабатывает специальный случай за вас. Таким образом, клиентский код не должен обрабатывать исключительное поведение.

- [x] **Не возвращайте null**
  - Когда мы возвращаем null, вызывающий код должен иметь проверку на null.
  - Решения могут быть такими:
    - Объект Special Case.
    - Возврат пустого списка.

- [x] **Не передавайте null в качестве аргументов**
  - Если вы передаете null, вызывающая функция всегда должна проверять аргументы на null.
    ```java
    public double xProjection(Point p1, Point p2) {
      if (p1 == null || p2 == null) {
         throw InvalidArgumentException(
           "Invalid argument for MetricsCalculator.xProjection");
      }
      return (p2.x – p1.x) * 1.5;
    }
    ```
    более чистый способ сделать это:
    ```java
    public double xProjection(Point p1, Point p2) {
       assert p1 != null : "p1 should not be null";
       assert p2 != null : "p2 should not be null";
       return (p2.x – p1.x) * 1.5;
    }
    ```
    Но это также не решает проблему, вместо `NullPointerException` мы получим другое `RuntimeException`.
  - Если ваш язык поддерживает это, используйте опциональные параметры, если возможно.

<br/>

---

<br/>

## Модульные тесты :umbrella:

- [x] **Следуйте трём законам TDD (test-driven development / Разработка через тестирование)**
  - Вы не можете писать продакшн код, пока не напишете неудачный модульный тест.
  - Вы не можете написать больше модульного теста, чем необходимо для его провала, и отсутствие компиляции также считается провалом.
  - Вы не можете писать больше продакшн кода, чем необходимо для прохождения текущего неудачного теста.

- [x] **Держите тесты в чистоте**
  - Тесты должны быть первоклассной частью проекта. Их необходимо поддерживать в такой же чистоте, как и продакшн код.
  - Тесты должны изменяться по мере эволюции продакшн кода. Чем грязнее тесты, тем труднее их менять.

- [x] **Следуйте шаблону "Сборка-Операция-Проверка"**
  - Первая часть создает тестовые данные, вторая часть оперирует этими данными, а третья часть проверяет, что операция дала ожидаемые результаты.
  - Это то же самое, что и паттерн "given-when-then".
  - Важно отделять данные части форматированием (отступы, переносы строк)

- [x] **Двойной стандарт**
  - Есть вещи, которые вы никогда не сделаете в продукционной среде, но которые вполне допустимы в тестовой среде. Обычно они связаны с проблемами памяти или эффективности процессора.

- [x] **Один assert на тест (гибкий подход)**
  - В идеале в тесте должен быть один assert.
  - Но допустимо, если их будет больше, в конечном итоге количество assert'ов в тесте должно быть минимизировано.
  - Цель — иметь один логический assert на тест или тестировать одно поведение в юнит-тесте.

- [x] **Единый концепт на тест**
  - Не оперируйте с разными данными и не пытайтесь их проверить в одном тесте.

- [x] **Методология F.I.R.S.T.**
  - FAST (быстрые): Тесты должны быть быстрыми.
  - INDEPENDENT (независимые): Тесты не должны зависеть друг от друга.
  - REPEATABLE (повторяемые): Тесты должны быть повторяемыми в любой среде.
  - SELF-VALIDATING (самопроверяемые): Тесты должны иметь логический результат (истина или ложь).
  - TIMELY (своевременные): Тесты должны быть написаны своевременно, в одно время с разрабатываемой функциональностью, если не раньше.
    - Модульные тесты должны писаться непосредственно перед продукционным кодом, который заставит их пройти.

<br/>

---

<br/>

## Класс :school_satchel:

- [x] **Организация класса** :arrow_down:
  - Переменные
    - Публичные статические константы
    - Приватные статические переменные
    - Приватные переменные экземпляра
  - Публичные функции
    - Связанные приватные функции

- [x] **Классы должны поддерживать инкапсуляцию**
  - Переменные и утилитарные функции должны быть приватными

- [x] **Классы должны быть маленькими и выполнять только одну задачу**
  - Название класса должно описывать его обязанности.
  - Если мы не можем придумать краткое название для класса, значит, он, вероятно, слишком велик.
  - Чем более расплывчатое название класса, тем больше вероятности, что у него слишком много обязанностей.
  - Мы также должны быть в состоянии написать краткое описание класса примерно в 25 словах, не используя слова "если", "и", "или" или "но". Если вам приходится использовать "и", то, вероятно, у класса несколько обязанностей.

- [x] **Принцип единственной ответственности**
  - Классы должны иметь только одну причину для изменения.

- [x] **Классы должны иметь связанность (cohesion)**
  - Классы должны иметь небольшое количество переменных экземпляра. Каждый метод класса должен манипулировать одной или несколькими из этих переменных.
  - Когда классы теряют связанность, разделите их.
  - Поведение приватных методов, которое применимо только к небольшому подмножеству класса, может быть полезной эвристикой. Это, вероятно, намек на то, что эту часть нужно выделить в отдельный класс.

- [x] **Классы должны зависеть от абстракций, а не от конкретных деталей (Принцип инверсии зависимостей)**

<br/>

---

<br/>

## Возникновение :green_book:

- [x] **Дизайн должен порождать систему, которая проходит все тесты, так как написание тестов способствует лучшему дизайну**
  - Система может иметь идеальный дизайн на бумаге, но если нет простого способа проверить, что система действительно работает так, как задумано, то вся теоретическая работа становится сомнительной.
  - Создание тестируемых систем способствует использованию дизайна, где классы малы и имеют одну четко определенную цель. Гораздо проще тестировать классы, которые соответствуют Принципу Единственной Ответственности.
  - Чем больше тестов мы пишем, тем больше мы стремимся к вещам, которые проще тестировать.
  - Плотная связанность затрудняет написание тестов. Таким же образом, чем больше тестов мы пишем, тем больше мы используем принципы, такие как Инверсия зависимостей и инструменты, такие как внедрение зависимостей, интерфейсы и абстракция, чтобы минимизировать связанность.
  - Факт наличия тестов устраняет страх, что изменение кода его сломает, и поэтому мы можем проводить рефакторинг и вносить изменения с уверенностью.

- [x] **Отсутствие дублирования**
  - Дублирование представляет собой дополнительную работу, дополнительный риск и излишнюю сложность.

- [x] **Выразительность**
  - Вы можете выражать себя, выбирая хорошие имена.
  - Вы также можете выражать себя, используя стандартные названия. Например, названия шаблонов проектирования, таких как Команда или Посетитель.
  - Хорошо написанные модульные тесты также являются выразительными. Одна из основных целей тестов — документировать поведение через примеры.

- [x] **Минимальное количество классов и методов**
  - Создавайте маленькие классы, но создавайте их тогда, когда это обосновано. Создание классов только для уменьшения количества строк кода является плохой практикой.
  - Следует избегать создания интерфейса для каждого класса. Поля и поведение всегда должны разделяться на классы данных и классы поведения.

<br/>

---

<br/>

## Параллелизм :arrows_clockwise:

- [x] **Параллелизм не всегда улучшает производительность**

- [x] **Для того чтобы сделать систему параллельной, может потребоваться изменить общую стратегию дизайна**

- [x] **Понимание потенциальных проблем параллелизма важно, даже если они сейчас не стоят перед вами как проблема**

- [x] **Содержите код, связанный с параллелизмом, отдельно от другого кода**

- [x] **Общие данные между потоками создают проблемы синхронизации, поэтому следите за инкапсуляцией данных, ограничивайте доступ к любым данным, которые могут быть общими**

- [x] **Вместо общих данных создавайте копии данных для различных потоков и собирайте их в конце обработки**

- [x] **Потоки должны быть как можно более независимыми и не должны обмениваться данными с другими потоками**

- [x] **Используйте потокобезопасные библиотечные функции**
  - Используйте предоставляемые коллекции, поддерживающие работу в многопоточной среде.
  - Используйте исполнительный фреймворк для выполнения независимых задач.
  - Используйте неблокирующие решения, когда это возможно.

- [x] **Используйте модель производитель-потребитель для параллельной работы**
  - Один или несколько производительских потоков создают работу и помещают её в буфер или очередь. Один или несколько потребительских потоков забирают эту работу из очереди и завершают её.

- [x] **Используйте модель читатели-писатели для параллельной работы**
  - Для систем с большим количеством чтения
    - Заставляет писателей ждать, пока нет читателей, прежде чем разрешить писателю выполнить обновление.
  - Для систем с большим количеством записи
    - Писателям следует быть приоритетными.

- [x] **Используйте различные стратегии блокировки, такие как**
  - Блокировка на стороне клиента
  - Блокировка на стороне сервера
  - Адаптированная блокировка на стороне сервера

- [x] **Держите секции синхронизации как можно меньше и избегайте побочных эффектов**

- [x] **Разработайте стратегию завершения, которая работает**

- [x] **Рассматривайте случайные сбои как потенциальные проблемы с потоками**

- [x] **Сначала заставьте работать ваш непотоковый код**
  - Не пытайтесь одновременно разобраться с ошибками, связанными с многопоточностью и без неё. Убедитесь, что ваш код работает без потоков.

- [x] **Сделайте ваш потоковый код подключаемым**
  - Сделайте ваш код на основе потоков особенно гибким, чтобы вы могли запускать его в различных конфигурациях.

- [x] **Сделайте ваш потоковый код настраиваемым**
  - Позвольте легко настраивать конфигурации, такие как количество потоков.

- [x] **Запускайте с большим количеством потоков, чем процессоров**

- [x] **Запускайте на разных платформах**

- [x] **Инструментируйте ваш код, чтобы выявить исключения**

<br/>

---

<br/>

## Пахнущий код :speak_no_evil:

- [x] **Если вы видите закомментированный код, удалите его**

- [x] **Неиспользуемый код следует удалить**

- [x] **Реализация должна быть очевидной**

- [x] **Ищите каждое граничное условие и напишите для него тест**

- [x] **Базовые классы не должны знать ничего о своих производных классах**

- [x] **Код должен быть последовательным**
  - Если в рамках определенной функции вы используете переменную с именем `response` для хранения `HttpServletResponse`, то следует использовать это же имя переменной последовательно в других функциях, где также используется `HttpServletResponse`.

- [x] **Предпочитайте нестатические методы статическим**
  - Если вы все-таки хотите, чтобы функция была статической, убедитесь, что нет шанса, что вам понадобится полиморфное поведение.

- [x] **Избегайте отрицательных условий**
  - `if (buffer.shouldCompact())` лучше, чем `if (!buffer.shouldNotCompact())`

- [x] **Инкапсулируйте граничные условия**
  - ```
    if (level + 1 < tags.length) {
      int nextLevel = level + 1;
      parts = new Parse(body, tags, nextLevel, offset + endTag);
      body = null;
    }
    ```
   `level + 1` — это граничная операция, которая повторяется, поэтому мы можем обернуть её в переменную, например, `nextLevel = level + 1`.

- [x] **Избегайте длинных списков импортов, используя маски**

- [x] **Не наследуйте константы**
  - Вместо этого используйте статические импорты.

- [x] **Используйте перечисления, а не `public static final int`/`String`**

## Почетные упоминания :basecamp:
В этом разделе я перечислю несколько вещей, которые являются абсолютно легендарными, но я их упустил. Для этих тем есть масса ресурсов онлайн, вы можете ознакомиться с ними там.

- [x] **Оригинальные принципы S.O.L.I.D. — ни одно обсуждение чистого кода не полное без них**

- [x] **Object Calisthenics:
  9 правил:
  - Только один уровень отступа в методе
  - Не используйте Else
  - Оберните все примитивные типы и строки
  - Коллекции первого класса
  - Одна точка на строку
  - Не используйте сокращения
  - Сохраняйте сущности короткими
  - Никаких классов с более чем 2 атрибутами
  - Никаких геттеров, сеттеров и свойств
